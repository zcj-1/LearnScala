package traitTemplate

/** @author Chaojay
  * @since 2018-12-13 11:49
  */
object TraitTemplate extends App {

  /**
    * trait:特质，可以当作接口使用。也是一个类。
    * 在trait中，可以有具体的实现的方法，没有实现的方法是抽象方法。
    * 通过extends 可以继承特质，通过with关键字可以混入多个特质
    */

  // 1、当作接口使用：Java中的接口没有具体实现方法，只有抽象方法

  // 2、带有具体实现方法的特质

  val drawAccount = new DrawAccount2
  drawAccount.withdraw(10)

  // 3、动态混入特质：在构建对象时混入某个具体的特质，覆盖掉抽象方法，提供具体实现

  // 4、叠加特质：动态混入的多个特质中有多个特质同时继承了同一个特质，并实现了共同方法

  // 5、在特质中重写抽象方法:重写的方法还可以是抽象方法

  // 6、当作富接口使用的特质:即该特质中既有抽象方法，又有非抽象方法

  // 7、特质中的具体字段
  /**
    * 特质中可以定义具体字段，如果初始化了就是具体字段，如果不初始化就是抽象字段。
      混入该特质的类就具有了该字段，字段不是继承，而是简单的加入类。是自己的字段
    */

  // 8、特质中的抽象字段
  /**
    * 特质中未被初始化的字段在具体的子类中必须被重写。
    */

  // 9、特质的构造顺序
  /**
    * 特质也是有构造器的，构造器中的内容由“字段的初始化”和一些其他语句构成
    */

  // 10、初始化特质中的字段
  /**
    * 特质不能有构造器参数，每个特质都有一个无参数的构造器。
    * "缺少构造器参数"是特质与类之间唯一的技术差别。
    * 除此之外，特质可以具备类的所有特性，比如具体的和抽象的字段，以及超类。
    */

  // 11、扩展类的特质
  /**
    * 1、特质可以继承自类，以用来拓展该类的一些功能
      2、所有混入该特质的类，会自动成为那个特质所继承的超类的子类
      3、如果混入该特质的类，已经继承了另一个类，不就矛盾了？注意，只要继承的那个类是特质超类的子类即可。
    */

  // 12、自身类型
  /**
    * 主要是为了解决特质的循环依赖问题，同时可以确保特质在不扩展某个类的情况下，依然可以做到限制混入该特质的类的类型
    */
}